# -*- coding: utf-8 -*-
"""WiDS_Week3_Day7.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mmmUdm2XW1en9PnPXm4jEFgpmKF3iX4A
"""

!pip install stable-baselines3 gymnasium

import numpy as np
import pandas as pd
import gymnasium as gym
from gymnasium import spaces
from stable_baselines3 import PPO
from stable_baselines3.common.env_util import make_vec_env
from stable_baselines3.common.monitor import Monitor
from collections import defaultdict
import matplotlib.pyplot as plt
import seaborn as sns
from collections import deque

class OrderBookMarket:
    def __init__(self, initial_price=100.0, tick_size=0.1):
        self.last_price = initial_price
        self.tick_size = tick_size
        self.bids = defaultdict(float)
        self.asks = defaultdict(float)

    def flush_book(self):
        self.bids.clear()
        self.asks.clear()

    def get_mid_price(self):
        best_bid = max(self.bids.keys()) if self.bids else self.last_price - 0.5
        best_ask = min(self.asks.keys()) if self.asks else self.last_price + 0.5
        return (best_bid + best_ask) / 2.0

    def post_limit_order(self, side, price, quantity):
        price = round(price / self.tick_size) * self.tick_size
        if side == "buy": self.bids[price] += quantity
        elif side == "sell": self.asks[price] += quantity

    def match_market_order(self, side, quantity):
        remaining = quantity
        exec_price = self.last_price

        if side == "buy":
            sorted_asks = sorted(self.asks.keys())
            for p in sorted_asks:
                if remaining <= 0: break
                matched = min(remaining, self.asks[p])
                self.asks[p] -= matched
                if self.asks[p] < 1e-9: del self.asks[p]
                remaining -= matched
                exec_price = p

        elif side == "sell":
            sorted_bids = sorted(self.bids.keys(), reverse=True)
            for p in sorted_bids:
                if remaining <= 0: break
                matched = min(remaining, self.bids[p])
                self.bids[p] -= matched
                if self.bids[p] < 1e-9: del self.bids[p]
                remaining -= matched
                exec_price = p

        self.last_price = exec_price
        return exec_price

class LOBTradingEnv(gym.Env):
    def __init__(self):
        super(LOBTradingEnv, self).__init__()

        self.action_space = spaces.Discrete(3)

        self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(4,), dtype=np.float32)

        self.market = OrderBookMarket()
        self.initial_cash = 10_000

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self.market = OrderBookMarket()
        self.inventory = 0
        self.cash = self.initial_cash
        self.step_count = 0

        self._generate_background_liquidity()

        return self._get_obs(), {}

    def _generate_background_liquidity(self):
        self.market.flush_book()
        mid = self.market.last_price

        mid += np.random.normal(0, 0.5)
        self.market.last_price = mid

        for i in range(1, 6):
            self.market.post_limit_order("sell", mid + i*0.2, 10)
        for i in range(1, 6):
            self.market.post_limit_order("buy", mid - i*0.2, 10)

    def _get_obs(self):
        mid_price = self.market.get_mid_price()
        portfolio_val = self.cash + (self.inventory * mid_price)

        return np.array([
            self.inventory / 10.0,
            self.cash / 10_000.0,
            mid_price / 100.0,
            portfolio_val / 10_000.0
        ], dtype=np.float32)

    def step(self, action):
        self.step_count += 1

        self._generate_background_liquidity()

        prev_val = self.cash + (self.inventory * self.market.get_mid_price())

        if action == 1:
            if self.cash > self.market.last_price:
                exec_price = self.market.match_market_order("buy", 1)
                self.inventory += 1
                self.cash -= exec_price

        elif action == 2:
            if self.inventory > -5:
                exec_price = self.market.match_market_order("sell", 1)
                self.inventory -= 1
                self.cash += exec_price

        current_val = self.cash + (self.inventory * self.market.get_mid_price())
        reward = current_val - prev_val

        reward -= 0.01 * abs(self.inventory)

        terminated = self.step_count >= 200
        truncated = False

        return self._get_obs(), reward, terminated, truncated, {}

env = make_vec_env(lambda: LOBTradingEnv(), n_envs=1)

model = PPO("MlpPolicy", env, verbose=1, learning_rate=0.0003)

print("Training Agent on LOB Market...")
model.learn(total_timesteps=10_000)
print("Training Complete.")

class BaseAgent:
    def __init__(self, agent_id):
        self.agent_id = agent_id

class NoiseTrader(BaseAgent):
    def __init__(self, agent_id):
        super().__init__(agent_id)

    def act(self, market):
        if np.random.random() < 0.10:
            side = np.random.choice(["buy", "sell"])
            qty = np.random.randint(1, 5)
            return ("market", side, qty)
        return ("hold", None, 0)

class MarketMaker(BaseAgent):
    def __init__(self, agent_id, spread=0.5, depth=5):
        super().__init__(agent_id)
        self.base_spread = spread
        self.depth = depth
        self.recent_returns = deque(maxlen=20)
        self.last_mid = None

    def act(self, market):
        mid = market.get_mid_price()

        if mid <= 1.0:
            mid = 1.0

        current_vol = 0

        if self.last_mid and self.last_mid > 0:
            try:
                ret = np.log(mid / self.last_mid)

                if np.isfinite(ret):
                    self.recent_returns.append(ret)

                if len(self.recent_returns) > 5:
                    current_vol = np.std(self.recent_returns)

                    if not np.isfinite(current_vol):
                        current_vol = 0
            except:
                current_vol = 0

        self.last_mid = mid

        multiplier = 1.0 + (current_vol * 40)
        multiplier = min(multiplier, 5.0)

        effective_spread = self.base_spread * multiplier

        orders = []
        for level in range(1, self.depth + 1):

            ask_p = mid + (effective_spread * level) + np.random.normal(0, 0.05)
            orders.append(("limit", "sell", max(ask_p, 0.01), 10))

            bid_p = mid - (effective_spread * level) + np.random.normal(0, 0.05)
            if bid_p > 0.01:
                orders.append(("limit", "buy", bid_p, 10))

        return orders

class TrendFollower(BaseAgent):
    def __init__(self, agent_id, window=10):
        super().__init__(agent_id)
        self.history = deque(maxlen=window)

    def act(self, market):
        self.history.append(market.last_price)

        if len(self.history) < self.history.maxlen:
            return ("hold", None, 0)

        sma = sum(self.history) / len(self.history)
        current = market.last_price

        qty = np.random.randint(5, 15)

        if current > sma + 1.0:
            return ("market", "buy", qty)
        elif current < sma - 1.0:
            return ("market", "sell", qty)

        return ("hold", None, 0)

class RLAgent:
    def __init__(self, agent_id, model):
        self.agent_id = agent_id
        self.model = model
        self.inventory = 0
        self.cash = 10_000

    def get_obs(self, market):
        mid_price = (market.last_price)
        portfolio_val = self.cash + (self.inventory * mid_price)

        return np.array([
            self.inventory / 10.0,
            self.cash / 10_000.0,
            mid_price / 100.0,
            portfolio_val / 10_000.0
        ], dtype=np.float32)

    def act(self, market):
        obs = self.get_obs(market)
        action, _ = self.model.predict(obs, deterministic=True)

        if action == 1: return ("market", "buy", 1)
        if action == 2: return ("market", "sell", 1)
        return ("hold", None, 0)

sim_market = OrderBookMarket()

mms = [MarketMaker(f"MM_{i}", spread=0.2) for i in range(15)]
tfs = [TrendFollower(f"TF_{i}", window=20) for i in range(5)]
noise_agents = [NoiseTrader(f"NT_{i}") for i in range(50)]
rl_agent = RLAgent("RL_Main", model)

history = []
price_path = []
market_sentiment = 0

for t in range(5000):

    sim_market.flush_book()
    for mm in mms:
        orders = mm.act(sim_market)
        for _, side, p, q in orders:
            sim_market.post_limit_order(side, p, q)

    market_sentiment = 0.9 * market_sentiment + np.random.normal(0, 0.2)
    market_sentiment = np.clip(market_sentiment, -1, 1)

    for nt in noise_agents:
        buy_prob = 0.5 + (0.3 * market_sentiment)
        if np.random.random() < 0.15:
            side = "buy" if np.random.random() < buy_prob else "sell"
            qty = np.random.randint(1, 3)
            sim_market.match_market_order(side, qty)

    for tf in tfs:
        type_, side, qty = tf.act(sim_market)
        if type_ == "market":
             sim_market.match_market_order(side, qty)

    type_, side, qty = rl_agent.act(sim_market)
    if type_ == "market":
        exec_price = sim_market.match_market_order(side, qty)
        if side == "buy":
            rl_agent.cash -= exec_price
            rl_agent.inventory += qty
        elif side == "sell":
            rl_agent.cash += exec_price
            rl_agent.inventory -= qty

    if t % 5 == 0:
        for p, v in sim_market.bids.items():
            history.append({'t': t, 'p': p, 'v': v})
        for p, v in sim_market.asks.items():
            history.append({'t': t, 'p': p, 'v': v})

    price_path.append(sim_market.last_price)

print("Simulation Complete. History length:", len(history))

recent_t = max(0, t - 500)
df_plot = pd.DataFrame(history)
df_plot = df_plot[df_plot['t'] > recent_t]

p_min = df_plot['p'].min()
p_max = df_plot['p'].max()
mat = df_plot.pivot_table(index='p', columns='t', values='v', aggfunc='sum').fillna(0)

plt.figure(figsize=(15, 7))
sns.heatmap(mat, cmap="magma", cbar_kws={'label': 'Liquidity Volume'})
plt.gca().invert_yaxis()

display_prices = price_path[recent_t:]
price_indices = [(p - mat.index.min()) / (mat.index.max() - mat.index.min()) * (len(mat)-1) for p in display_prices]
plt.plot(np.arange(len(price_indices)), price_indices, color='cyan', linewidth=2, label="Market Price")

plt.title("Market Dynamics")
plt.legend()
plt.show()

price_df = pd.DataFrame({
    "t": np.arange(len(price_path)),
    "price": price_path
})

price_df.to_csv("market_price.csv", index = False)

print("Saved market_price")

df = pd.read_csv("market_price.csv")
df.head()

df["log_price"] = np.log(df["price"])
df["r"] = df["log_price"].diff()

df = df.dropna()

plt.figure(figsize = (12, 4))
plt.plot(df["t"], df["r"], linewidth = 0.6)
plt.title("Log Returns Over Time")
plt.xlabel("Time")
plt.ylabel("Return")
plt.show()

from statsmodels.tsa.stattools import acf

abs_returns = np.abs(df["r"])
acf_vals = acf(abs_returns, nlags = 50)

plt.figure(figsize = (10, 4))
plt.plot(acf_vals)
plt.axhline(0, color = "black", linewidth = 0.5)
plt.title("ACF of |Returns|")
plt.xlabel("Lag")
plt.ylabel("Autocorrelation")
plt.show()

plt.figure(figsize = (8, 4))
plt.hist(df["r"], bins = 100, density = True, alpha = 0.6)
plt.title("Return Distribution")
plt.xlabel("Return")
plt.ylabel("Density")
plt.show()

mu = df["r"].mean()
sigma = df["r"].std()

x = np.linspace(df["r"].min(), df["r"].max(), 500)
gaussian = (1 / (sigma * np.sqrt(2 * np.pi))) * np.exp(-(x - mu)**2 / (2 * sigma **2))

plt.figure(figsize = (8, 4))
plt.hist(df["r"], bins = 100, density = True, alpha = 0.6, label = "Simulated Returns")
plt.plot(x, gaussian, linewidth = 2, label = "Gaussian")
plt.legend()
plt.title("Returns vs Gaussian")
plt.show()

from scipy.stats import kurtosis

k = kurtosis(df["r"], fisher = False)
print("Empirical kurtosis:", k)