# -*- coding: utf-8 -*-
"""WiDS_Week3_Day6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1V57OHehgd-4qiBkwEI8qJ1LSOvUtbzna
"""

!pip install stable-baselines3 gymnasium

import numpy as np
import pandas as pd
import gymnasium as gym
from gymnasium import spaces
from stable_baselines3 import PPO
from stable_baselines3.common.env_util import make_vec_env
from stable_baselines3.common.monitor import Monitor
from collections import defaultdict
import matplotlib.pyplot as plt
import seaborn as sns

class OrderBookMarket:
    def __init__(self, initial_price=100.0, tick_size=0.1):
        self.last_price = initial_price
        self.tick_size = tick_size
        self.bids = defaultdict(float)
        self.asks = defaultdict(float)

    def flush_book(self):
        self.bids.clear()
        self.asks.clear()

    def get_mid_price(self):
        best_bid = max(self.bids.keys()) if self.bids else self.last_price - 0.5
        best_ask = min(self.asks.keys()) if self.asks else self.last_price + 0.5
        return (best_bid + best_ask) / 2.0

    def post_limit_order(self, side, price, quantity):
        price = round(price / self.tick_size) * self.tick_size
        if side == "buy": self.bids[price] += quantity
        elif side == "sell": self.asks[price] += quantity

    def match_market_order(self, side, quantity):
        remaining = quantity
        exec_price = self.last_price

        if side == "buy":
            sorted_asks = sorted(self.asks.keys())
            for p in sorted_asks:
                if remaining <= 0: break
                matched = min(remaining, self.asks[p])
                self.asks[p] -= matched
                if self.asks[p] < 1e-9: del self.asks[p]
                remaining -= matched
                exec_price = p

        elif side == "sell":
            sorted_bids = sorted(self.bids.keys(), reverse=True)
            for p in sorted_bids:
                if remaining <= 0: break
                matched = min(remaining, self.bids[p])
                self.bids[p] -= matched
                if self.bids[p] < 1e-9: del self.bids[p]
                remaining -= matched
                exec_price = p

        self.last_price = exec_price
        return exec_price

class LOBTradingEnv(gym.Env):
    def __init__(self):
        super(LOBTradingEnv, self).__init__()

        self.action_space = spaces.Discrete(3)

        self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(4,), dtype=np.float32)

        self.market = OrderBookMarket()
        self.initial_cash = 10_000

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self.market = OrderBookMarket()
        self.inventory = 0
        self.cash = self.initial_cash
        self.step_count = 0

        self._generate_background_liquidity()

        return self._get_obs(), {}

    def _generate_background_liquidity(self):
        self.market.flush_book()
        mid = self.market.last_price

        mid += np.random.normal(0, 0.5)
        self.market.last_price = mid

        for i in range(1, 6):
            self.market.post_limit_order("sell", mid + i*0.2, 10)
        for i in range(1, 6):
            self.market.post_limit_order("buy", mid - i*0.2, 10)

    def _get_obs(self):
        mid_price = self.market.get_mid_price()
        portfolio_val = self.cash + (self.inventory * mid_price)

        return np.array([
            self.inventory / 10.0,
            self.cash / 10_000.0,
            mid_price / 100.0,
            portfolio_val / 10_000.0
        ], dtype=np.float32)

    def step(self, action):
        self.step_count += 1

        self._generate_background_liquidity()

        prev_val = self.cash + (self.inventory * self.market.get_mid_price())

        if action == 1:
            if self.cash > self.market.last_price:
                exec_price = self.market.match_market_order("buy", 1)
                self.inventory += 1
                self.cash -= exec_price

        elif action == 2:
            if self.inventory > -5:
                exec_price = self.market.match_market_order("sell", 1)
                self.inventory -= 1
                self.cash += exec_price

        current_val = self.cash + (self.inventory * self.market.get_mid_price())
        reward = current_val - prev_val

        reward -= 0.01 * abs(self.inventory)

        terminated = self.step_count >= 200
        truncated = False

        return self._get_obs(), reward, terminated, truncated, {}

env = make_vec_env(lambda: LOBTradingEnv(), n_envs=1)

model = PPO("MlpPolicy", env, verbose=1, learning_rate=0.0003)

print("Training Agent on LOB Market...")
model.learn(total_timesteps=10_000)
print("Training Complete.")

class BaseAgent:
    def __init__(self, agent_id):
        self.agent_id = agent_id

class NoiseTrader(BaseAgent):
    def __init__(self, agent_id):
        super().__init__(agent_id)

    def act(self, market):
        if np.random.random() < 0.10:
            side = np.random.choice(["buy", "sell"])
            qty = np.random.randint(1, 5)
            return ("market", side, qty)
        return ("hold", None, 0)

class MarketMaker(BaseAgent):
    def __init__(self, agent_id, spread=0.5, depth=5):
        super().__init__(agent_id)
        self.spread = spread
        self.depth = depth

    def act(self, market):
        mid = market.last_price
        orders = []

        for level in range(1, self.depth + 1):
            ask_p = mid + (self.spread * level) + np.random.normal(0, 0.05)
            orders.append(("limit", "sell", ask_p, 10))

            bid_p = mid - (self.spread * level) + np.random.normal(0, 0.05)
            orders.append(("limit", "buy", bid_p, 10))

        return orders

class RLAgent:
    def __init__(self, agent_id, model):
        self.agent_id = agent_id
        self.model = model
        self.inventory = 0
        self.cash = 10_000

    def get_obs(self, market):
        mid_price = (market.last_price)
        portfolio_val = self.cash + (self.inventory * mid_price)

        return np.array([
            self.inventory / 10.0,
            self.cash / 10_000.0,
            mid_price / 100.0,
            portfolio_val / 10_000.0
        ], dtype=np.float32)

    def act(self, market):
        obs = self.get_obs(market)
        action, _ = self.model.predict(obs, deterministic=True)

        if action == 1: return ("market", "buy", 1)
        if action == 2: return ("market", "sell", 1)
        return ("hold", None, 0)

sim_market = OrderBookMarket()
rl_agent = RLAgent("RL_Main", model)
mms = [MarketMaker(f"MM_{i}") for i in range(10)]
noise = [NoiseTrader(f"NT_{i}") for i in range(50)]

history = []
price_path = []

print("Running Measurement Simulation...")
for t in range(5000):

    sim_market.flush_book()
    for mm in mms:
        orders = mm.act(sim_market)
        for _, side, p, q in orders:
            sim_market.post_limit_order(side, p, q)

    for p, v in sim_market.bids.items(): history.append({'t': t, 'p': p, 'v': v})
    for p, v in sim_market.asks.items(): history.append({'t': t, 'p': p, 'v': v})

    for nt in noise:
        type_, side, qty = nt.act(sim_market)
        if type_ == "market": sim_market.match_market_order(side, qty)

    type_, side, qty = rl_agent.act(sim_market)
    if type_ == "market":
        exec_price = sim_market.match_market_order(side, qty)
        if side == "buy":
            rl_agent.cash -= exec_price
            rl_agent.inventory += qty
        elif side == "sell":
            rl_agent.cash += exec_price
            rl_agent.inventory -= qty

    price_path.append(sim_market.last_price)

df = pd.DataFrame(history)
df = df[(df['p'] > 90) & (df['p'] < 110)]
mat = df.pivot_table(index='p', columns='t', values='v', aggfunc='sum').fillna(0)

plt.figure(figsize=(12, 6))
sns.heatmap(mat, cmap="inferno", robust=True)
plt.gca().invert_yaxis()
scaled_price = [(p - mat.index.min()) / (mat.index.max() - mat.index.min()) * len(mat) for p in price_path]
plt.plot(scaled_price, color='white', linewidth=1.5, label="Market Price")
plt.legend()
plt.title("Market Simulation: RL Agent + Noise Traders vs Liquidity Walls")
plt.show()