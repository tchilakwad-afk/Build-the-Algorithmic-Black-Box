# -*- coding: utf-8 -*-
"""WiDS_Week3_Day8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HgQm5x5C37eQLX3Ojji3vQoJ1zwNmDYw
"""

!pip install stable-baselines3 gymnasium

import numpy as np
import pandas as pd
import gymnasium as gym
from gymnasium import spaces
from stable_baselines3 import PPO
from stable_baselines3.common.env_util import make_vec_env
from stable_baselines3.common.monitor import Monitor
from collections import defaultdict
import matplotlib.pyplot as plt
import seaborn as sns
from collections import deque

class OrderBookMarket:
    def __init__(self, initial_price=100.0, tick_size=0.1):
        self.last_price = initial_price
        self.tick_size = tick_size
        self.bids = defaultdict(float)
        self.asks = defaultdict(float)

    def flush_book(self):
        self.bids.clear()
        self.asks.clear()

    def get_mid_price(self):
        best_bid = max(self.bids.keys()) if self.bids else self.last_price - 0.5
        best_ask = min(self.asks.keys()) if self.asks else self.last_price + 0.5
        return (best_bid + best_ask) / 2.0

    def post_limit_order(self, side, price, quantity):
        price = round(price / self.tick_size) * self.tick_size
        if side == "buy": self.bids[price] += quantity
        elif side == "sell": self.asks[price] += quantity

    def match_market_order(self, side, quantity):
        remaining = quantity
        exec_price = self.last_price

        if side == "buy":
            sorted_asks = sorted(self.asks.keys())
            for p in sorted_asks:
                if remaining <= 0: break
                matched = min(remaining, self.asks[p])
                self.asks[p] -= matched
                if self.asks[p] < 1e-9: del self.asks[p]
                remaining -= matched
                exec_price = p

        elif side == "sell":
            sorted_bids = sorted(self.bids.keys(), reverse=True)
            for p in sorted_bids:
                if remaining <= 0: break
                matched = min(remaining, self.bids[p])
                self.bids[p] -= matched
                if self.bids[p] < 1e-9: del self.bids[p]
                remaining -= matched
                exec_price = p

        self.last_price = exec_price
        return exec_price

class LOBTradingEnv(gym.Env):
    def __init__(self):
        super(LOBTradingEnv, self).__init__()

        self.action_space = spaces.Discrete(3)

        self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(4,), dtype=np.float32)

        self.market = OrderBookMarket()
        self.initial_cash = 10_000

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self.market = OrderBookMarket()
        self.inventory = 0
        self.cash = self.initial_cash
        self.step_count = 0

        self._generate_background_liquidity()

        return self._get_obs(), {}

    def _generate_background_liquidity(self):
        self.market.flush_book()
        mid = self.market.last_price

        mid += np.random.normal(0, 0.5)
        self.market.last_price = mid

        for i in range(1, 6):
            self.market.post_limit_order("sell", mid + i*0.2, 10)
        for i in range(1, 6):
            self.market.post_limit_order("buy", mid - i*0.2, 10)

    def _get_obs(self):
        mid_price = self.market.get_mid_price()
        portfolio_val = self.cash + (self.inventory * mid_price)

        return np.array([
            self.inventory / 10.0,
            self.cash / 10_000.0,
            mid_price / 100.0,
            portfolio_val / 10_000.0
        ], dtype=np.float32)

    def step(self, action):
        self.step_count += 1

        self._generate_background_liquidity()

        prev_val = self.cash + (self.inventory * self.market.get_mid_price())

        if action == 1:
            if self.cash > self.market.last_price:
                exec_price = self.market.match_market_order("buy", 1)
                self.inventory += 1
                self.cash -= exec_price

        elif action == 2:
            if self.inventory > -5:
                exec_price = self.market.match_market_order("sell", 1)
                self.inventory -= 1
                self.cash += exec_price

        current_val = self.cash + (self.inventory * self.market.get_mid_price())
        reward = current_val - prev_val

        reward -= 0.01 * abs(self.inventory)

        terminated = self.step_count >= 200
        truncated = False

        return self._get_obs(), reward, terminated, truncated, {}

env = make_vec_env(lambda: LOBTradingEnv(), n_envs=1)

model = PPO("MlpPolicy", env, verbose=1, learning_rate=0.0003)

print("Training Agent on LOB Market...")
model.learn(total_timesteps=10_000)
print("Training Complete.")

class BaseAgent:
    def __init__(self, agent_id):
        self.agent_id = agent_id

class NoiseTrader(BaseAgent):
  def __init__(self, agent_id):
    super().__init__(agent_id)

  def act(self, market):
    if np.random.random() < 0.10:
        side = np.random.choice(["buy", "sell"])
        qty = np.random.randint(1, 5)
        return ("market", side, qty)
    return ("hold", None, 0)

class MarketMaker(BaseAgent):
  def __init__(self, agent_id, spread=0.5, depth=5):
    super().__init__(agent_id)
    self.base_spread = spread
    self.depth = depth
    self.recent_returns = deque(maxlen=20)
    self.last_mid = None

  def act(self, market):
    mid = market.get_mid_price()

    if mid <= 1.0:
        mid = 1.0

    current_vol = 0

    if self.last_mid and self.last_mid > 0:
        try:
            ret = np.log(mid / self.last_mid)

            if np.isfinite(ret):
                self.recent_returns.append(ret)

            if len(self.recent_returns) > 5:
                current_vol = np.std(self.recent_returns)

                if not np.isfinite(current_vol):
                    current_vol = 0
        except:
            current_vol = 0

    self.last_mid = mid

    multiplier = 1.0 + (current_vol * 40)
    multiplier = min(multiplier, 5.0)

    effective_spread = self.base_spread * multiplier

    orders = []
    for level in range(1, self.depth + 1):

        ask_p = mid + (effective_spread * level) + np.random.normal(0, 0.05)
        orders.append(("limit", "sell", max(ask_p, 0.01), 10))

        bid_p = mid - (effective_spread * level) + np.random.normal(0, 0.05)
        if bid_p > 0.01:
            orders.append(("limit", "buy", bid_p, 10))

    return orders

class TrendFollower(BaseAgent):
  def __init__(self, agent_id, window=20, panic_threshold=2.0):
    super().__init__(agent_id)
    self.history = deque(maxlen=window)
    self.inventory = 0
    self.panic_threshold = panic_threshold

  def act(self, market):
    self.history.append(market.last_price)

    if len(self.history) < self.history.maxlen:
        return ("hold", None, 0)

    sma = sum(self.history) / len(self.history)
    current = market.last_price
    deviation = current - sma

    if abs(deviation) < self.panic_threshold:
        if np.random.random() < 0.65:
            qty = 1
            if deviation > 0: return ("market", "sell", qty)
            else: return ("market", "buy", qty)
        return ("hold", None, 0)

    qty = np.random.randint(2, 6)
    if deviation > self.panic_threshold:
        self.inventory += qty
        return ("market", "buy", qty)
    elif deviation < -self.panic_threshold:
        self.inventory -= qty
        return ("market", "sell", qty)

    return ("hold", None, 0)

class RLAgent:
  def __init__(self, agent_id, model):
    self.agent_id = agent_id
    self.model = model
    self.inventory = 0
    self.cash = 10_000

  def get_obs(self, market):
    mid_price = (market.last_price)
    portfolio_val = self.cash + (self.inventory * mid_price)

    return np.array([
        self.inventory / 10.0,
        self.cash / 10_000.0,
        mid_price / 100.0,
        portfolio_val / 10_000.0
    ], dtype=np.float32)

  def act(self, market):
    obs = self.get_obs(market)
    action, _ = self.model.predict(obs, deterministic=True)

    if action == 1: return ("market", "buy", 1)
    if action == 2: return ("market", "sell", 1)
    return ("hold", None, 0)

sim_market = OrderBookMarket()

mms = [MarketMaker(f"MM_{i}", spread=0.2) for i in range(15)]

tfs = []
for i in range(30):
  w = np.random.randint(10, 50)
  thresh = np.random.uniform(0.2, 4.0)
  tfs.append(TrendFollower(f"TF_{i}", window = w, panic_threshold = thresh))

noise_agents = [NoiseTrader(f"NT_{i}") for i in range(100)]
rl_agent = RLAgent("RL_Main", model)

history = []
price_path = []
market_sentiment = 0

position_history = {
    agent.agent_id: [] for agent in tfs
}
position_history["RL_Main"] = []

for t in range(5000):
  sim_market.flush_book()
  for mm in mms:
      orders = mm.act(sim_market)
      for _, side, p, q in orders:
          sim_market.post_limit_order(side, p, q)

  if 2500 <= t < 2550:
    market_sentiment = -8.0
  elif 2550 <= t < 3000:
    market_sentiment = 2.0
  else:
    market_sentiment = 0.9 * market_sentiment + np.random.normal(0, 0.5)
    market_sentiment = np.clip(market_sentiment, -2, 2)

  for nt in noise_agents:
      buy_prob = 1 / (1 + np.exp(-market_sentiment))
      if np.random.random() < 0.30:
          side = "buy" if np.random.random() < buy_prob else "sell"
          qty = np.random.randint(1, 3)
          sim_market.match_market_order(side, qty)

  for tf in tfs:
      type_, side, qty = tf.act(sim_market)
      if type_ == "market":
            sim_market.match_market_order(side, qty)

  type_, side, qty = rl_agent.act(sim_market)
  if type_ == "market":
      exec_price = sim_market.match_market_order(side, qty)
      if side == "buy":
          rl_agent.cash -= exec_price
          rl_agent.inventory += qty
      elif side == "sell":
          rl_agent.cash += exec_price
          rl_agent.inventory -= qty

  if t % 5 == 0:
      for p, v in sim_market.bids.items():
          history.append({'t': t, 'p': p, 'v': v})
      for p, v in sim_market.asks.items():
          history.append({'t': t, 'p': p, 'v': v})

  price_path.append(sim_market.last_price)
  for tf in tfs:
    position_history[tf.agent_id].append(tf.inventory)

  position_history["RL_Main"].append(rl_agent.inventory)

print("Simulation Complete. History length:", len(history))

pos_df = pd.DataFrame(position_history)
price_df = pd.DataFrame({"price": price_path})

window_size = 100
mean_corr = []
plot_times = []

for t in range(window_size, len(pos_df), 10):
  window_data = pos_df.iloc[t-window_size : t]

  active_agents = window_data.columns[window_data.std() > 0]

  if len(active_agents) > 2:
    corr_matrix = window_data[active_agents].corr()
    upper_tri = corr_matrix.where(np.triu(np.ones(corr_matrix.shape), k=1).astype(bool))
    avg_c = upper_tri.stack().mean()
    mean_corr.append(avg_c)
  else:
    mean_corr.append(0)

  plot_times.append(t)

price_df["returns"] = np.log(price_df["price"]).diff()
rolling_vol = price_df["returns"].rolling(window=window_size).std()
aligned_vol = rolling_vol.iloc[plot_times].values

fig, (ax1, ax2, ax3) = plt.subplots(3, 1, figsize=(12, 12), sharex=True)

ax1.plot(price_df.index, price_df["price"], color='black', label='Mid Price')
ax1.set_ylabel('Price')
ax1.set_title("Market Dynamics & Herding Analysis")
ax1.axvspan(2500, 2550, color='red', alpha=0.1, label='External Shock')

ax2.plot(plot_times, aligned_vol, color='tab:blue', label='Volatility')
ax2.set_ylabel('Volatility')

ax3.plot(plot_times, mean_corr, color='tab:red', linewidth=2, label='Pairwise Correlation')
ax3.axhline(0.7, color='gray', linestyle='--', label='Herding Threshold')
ax3.set_ylabel('Correlation')
ax3.set_xlabel('Time Step')

plt.tight_layout()
plt.show()