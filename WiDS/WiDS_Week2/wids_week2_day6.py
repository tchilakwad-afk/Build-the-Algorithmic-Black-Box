# -*- coding: utf-8 -*-
"""WiDS_Week2_Day6.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/134db8dcHf8i07yna60AclKKVsTitSBtV
"""

import heapq
from collections import deque
import random
import time
from dataclasses import dataclass
from abc import ABC, abstractmethod

@dataclass
class Order:
  order_id: int
  trader_id: int
  side: str
  type: str
  price: float | None
  qty: int
  timestamp: float
  status: str = "open"

@dataclass
class Trade:
  price: float
  qty: int
  buyer_id: int
  seller_id: int
  aggressor_side: str
  timestamp: float

class OrderBook:
    def __init__(self):
        self.bids = {}
        self.asks = {}

        self.trade_log = []
        self.l1_snapshots = []

    def add_order(self, order: Order):
        if order.type == "limit":
            book = self.bids if order.side == "buy" else self.asks
            price = order.price

            if price not in book:
                book[price] = deque()

            book[price].append(order)

        self.match(order)
        self.record_l1(order.timestamp)

    def match(self, incoming: Order):
        while incoming.qty > 0:
            if incoming.side == "buy":
                if not self.asks:
                    break
                best_ask = min(self.asks)
                if incoming.type == "limit" and incoming.price < best_ask:
                    break
                resting = self.asks[best_ask][0]
                trade_price = best_ask
            else:
                if not self.bids:
                    break
                best_bid = max(self.bids)
                if incoming.type == "limit" and incoming.price > best_bid:
                    break
                resting = self.bids[best_bid][0]
                trade_price = best_bid

            trade_qty = min(incoming.qty, resting.qty)
            if trade_qty <= 0:
                break

            self.trade_log.append(
                Trade(
                    price=trade_price,
                    qty=trade_qty,
                    buyer_id=incoming.trader_id if incoming.side == "buy" else resting.trader_id,
                    seller_id=resting.trader_id if incoming.side == "buy" else incoming.trader_id,
                    aggressor_side=incoming.side,
                    timestamp=incoming.timestamp
                )
            )

            incoming.qty -= trade_qty
            resting.qty -= trade_qty

            if resting.qty == 0:
                if incoming.side == "buy":
                    self.asks[best_ask].popleft()
                    if not self.asks[best_ask]:
                        del self.asks[best_ask]
                else:
                    self.bids[best_bid].popleft()
                    if not self.bids[best_bid]:
                        del self.bids[best_bid]

    def record_l1(self, timestamp):
        if not self.bids or not self.asks:
            return

        best_bid = max(self.bids)
        best_ask = min(self.asks)

        if best_bid >= best_ask:
          return

        self.l1_snapshots.append({
            "timestamp": timestamp,
            "best_bid": best_bid,
            "best_ask": best_ask
        })

def seed_initial_liquidity(book: OrderBook, mid = 100.0, spread = 1.0):
  timestamp = 0.0

  bid_order = Order(
      order_id = 0,
      trader_id = -1,
      side = "buy",
      type = "limit",
      price = mid - spread/2,
      qty = 1_000,
      timestamp = timestamp
  )

  ask_order = Order(
      order_id = -1,
      trader_id = -2,
      side = "sell",
      type = "limit",
      price = mid + spread/2,
      qty = 1_000,
      timestamp = timestamp
  )

  book.add_order(bid_order)
  book.add_order(ask_order)

class Agent(ABC):
  def __init__(self, agent_id, balance = 1_000_000, inventory = 0):
    self.id = agent_id
    self.balance = balance
    self.inventory = inventory

  @abstractmethod
  def get_action(self, market_snapshot):
    # returns dict describing an order intent
    pass

class RandomAgent(Agent):
    def get_action(self, market_snapshot):
        side = random.choice(["buy", "sell"])
        qty = random.randint(1, 10)

        if market_snapshot["mid"] is None:
            return {
                "side": side,
                "type": "market",
                "price": None,
                "qty": qty
            }

        order_type = random.choices(
            ["limit", "market"],
            weights=[0.7, 0.3]
        )[0]

        if order_type == "limit":
            price = round(
                market_snapshot["mid"] + random.uniform(-1, 1),
                2
            )
        else:
            price = None

        return {
            "side": side,
            "type": order_type,
            "price": price,
            "qty": qty
        }

def get_l1_snapshot(order_book):
  best_bid = max(order_book.bids.keys()) if order_book.bids else None
  best_ask = min(order_book.asks.keys()) if order_book.asks else None

  return {
      "best_bid": best_bid,
      "best_ask": best_ask,
      "mid": (
          (best_bid + best_ask) / 2
          if best_bid is not None and best_ask is not None
          else None
      )
  }

def intent_to_order(intent, agent_id, order_id, timestamp):
  return Order(
      order_id = order_id,
      trader_id = agent_id,
      side = intent["side"],
      type = intent["type"],
      price = intent["price"],
      qty = intent["qty"],
      timestamp = timestamp
  )

def run_agent_simulation(agents, order_book, n_steps = 1_000):
  order_id = 1
  current_time = 0.0

  for _ in range(n_steps):
    current_time += random.expovariate(5)

    agent = random.choice(agents)
    snapshot = get_l1_snapshot(order_book)

    intent = agent.get_action(snapshot)
    if intent is None:
      continue

    order = intent_to_order(
        intent = intent,
        agent_id = agent.id,
        timestamp = current_time,
        order_id = order_id
    )

    order_book.add_order(order)
    order_id += 1

  return order_book

book = OrderBook()
seed_initial_liquidity(book)

agents = [RandomAgent(i) for i in range(1, 21)]

engine = run_agent_simulation(agents = agents, order_book=book, n_steps=500)

print(len(engine.trade_log), "trades executed")
print(len(engine.l1_snapshots), "L1 snapshots recorded")