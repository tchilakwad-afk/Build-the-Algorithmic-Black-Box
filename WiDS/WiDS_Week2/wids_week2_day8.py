# -*- coding: utf-8 -*-
"""WiDS_Week2_Day8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bqeTtWYk_vQWri2NYVginPce2LOWT4hh
"""

import heapq
from dataclasses import dataclass
from collections import deque
import time
import random
from abc import ABC, abstractmethod

@dataclass
class Order:
  order_id: int
  trader_id: int
  side: str
  type: str
  price: float | None
  qty: int
  timestamp: float
  status: str = "open"

@dataclass
class Trade:
  price: float
  qty: int
  buyer_id: int
  seller_id: int
  aggressor_side: str
  timestamp: float

class Agent(ABC):
  def __init__(self, agent_id, balance = 1_000_000, inventory = 0):
    self.id = agent_id
    self.balance = balance
    self.inventory = inventory

  @abstractmethod
  def get_action(self, market_snapshot):
    # returns dict describing an order intent
    pass

class OrderBook:
    def __init__(self):
        self.bids = {}
        self.asks = {}

        self.trade_log = []
        self.l1_snapshots = []

    def add_order(self, order: Order):
        if order.type == "limit":
            book = self.bids if order.side == "buy" else self.asks
            price = order.price

            if price not in book:
                book[price] = deque()

            book[price].append(order)

        self.match(order)
        self.record_l1(order.timestamp)

    def match(self, incoming: Order):
        while incoming.qty > 0:
            if incoming.side == "buy":
                if not self.asks:
                    break
                best_ask = min(self.asks)
                if incoming.type == "limit" and incoming.price < best_ask:
                    break
                resting = self.asks[best_ask][0]
                trade_price = best_ask
            else:
                if not self.bids:
                    break
                best_bid = max(self.bids)
                if incoming.type == "limit" and incoming.price > best_bid:
                    break
                resting = self.bids[best_bid][0]
                trade_price = best_bid

            trade_qty = min(incoming.qty, resting.qty)
            if trade_qty <= 0:
                break

            self.trade_log.append(
                Trade(
                    price=trade_price,
                    qty=trade_qty,
                    buyer_id=incoming.trader_id if incoming.side == "buy" else resting.trader_id,
                    seller_id=resting.trader_id if incoming.side == "buy" else incoming.trader_id,
                    aggressor_side=incoming.side,
                    timestamp=incoming.timestamp
                )
            )

            incoming.qty -= trade_qty
            resting.qty -= trade_qty

            if resting.qty == 0:
                if incoming.side == "buy":
                    self.asks[best_ask].popleft()
                    if not self.asks[best_ask]:
                        del self.asks[best_ask]
                else:
                    self.bids[best_bid].popleft()
                    if not self.bids[best_bid]:
                        del self.bids[best_bid]

    def record_l1(self, timestamp):
        if not self.bids or not self.asks:
            return

        best_bid = max(self.bids)
        best_ask = min(self.asks)

        if best_bid >= best_ask:
          return

        self.l1_snapshots.append({
            "timestamp": timestamp,
            "best_bid": best_bid,
            "best_ask": best_ask
        })

def seed_initial_liquidity(book: OrderBook, mid = 100.0, spread = 1.0):
  timestamp = 0.0

  bid_order = Order(
      order_id = 0,
      trader_id = -1,
      side = "buy",
      type = "limit",
      price = mid - spread/2,
      qty = 1_000,
      timestamp = timestamp
  )

  ask_order = Order(
      order_id = -1,
      trader_id = -2,
      side = "sell",
      type = "limit",
      price = mid + spread/2,
      qty = 1_000,
      timestamp = timestamp
  )

  book.add_order(bid_order)
  book.add_order(ask_order)

def intent_to_order(intent, agent_id, order_id, timestamp):
  return Order(
      order_id = order_id,
      trader_id = agent_id,
      side = intent["side"],
      type = intent["type"],
      price = intent["price"],
      qty = intent["qty"],
      timestamp = timestamp
  )

class MomentumAgent(Agent):
  def __init__(self, agent_id, window = 50):
    super().__init__(agent_id)
    self.window = window
    self.prices = deque(maxlen = window)

  def get_action(self, market_snapshot):
    mid = market_snapshot.get("mid")

    if mid is None:
      return None

    self.prices.append(mid)

    if len(self.prices) < self.window:
      return None

    sma = sum(self.prices) / len(self.prices)
    eps= random.uniform(-0.01, 0.01)

    if mid + eps > sma:
      return {
          "side": "buy",
          "type": "market",
          "price": None,
          "qty": 1
      }

    elif mid + eps < sma:
      return {
          "side": "sell",
          "type": "market",
          "price": None,
          "qty": 1
      }

    return None

class MarketMakerAgent(Agent):
    def __init__(self, agent_id, spread=1.0, size=50):
        super().__init__(agent_id)
        self.spread = spread
        self.size = size

    def get_action(self, market_snapshot):
        best_bid = market_snapshot.get("best_bid")
        best_ask = market_snapshot.get("best_ask")

        if best_bid is None or best_ask is None:
            return None

        return [
            {
                "side": "buy",
                "type": "limit",
                "price": round(best_bid - 0.01, 2),
                "qty": self.size
            },
            {
                "side": "sell",
                "type": "limit",
                "price": round(best_ask + 0.01, 2),
                "qty": self.size
            }
        ]

def get_l1_snapshot(order_book):
  best_bid = max(order_book.bids.keys()) if order_book.bids else None
  best_ask = min(order_book.asks.keys()) if order_book.asks else None

  return {
      "best_bid": best_bid,
      "best_ask": best_ask,
      "mid": (
          (best_bid + best_ask) / 2
          if best_bid is not None and best_ask is not None
          else None
      )
  }

def run_agent_simulation(agents, order_book, n_steps=1_000):
    order_id = 1
    current_time = 0.0

    market_makers = [a for a in agents if isinstance(a, MarketMakerAgent)]
    traders = [a for a in agents if not isinstance(a, MarketMakerAgent)]

    for _ in range(n_steps):
        current_time += random.expovariate(5)

        snapshot = get_l1_snapshot(order_book)
        for mm in market_makers:
            intents = mm.get_action(snapshot)
            if intents is None:
                continue
            for intent in intents:
                order = intent_to_order(intent, mm.id, order_id, current_time)
                order_book.add_order(order)
                order_id += 1

        trader = random.choice(traders)
        snapshot = get_l1_snapshot(order_book)
        intent = trader.get_action(snapshot)
        if intent is None:
            continue

        order = intent_to_order(intent, trader.id, order_id, current_time)
        order_book.add_order(order)
        order_id += 1

    return order_book

book = OrderBook()

seed_initial_liquidity(book)

agents = (
    [MarketMakerAgent(i) for i in range(1,6)] +
    [MomentumAgent(i) for i in range (6, 11)]
)

engine = run_agent_simulation(
    agents = agents,
    order_book = book,
    n_steps = 10_000
)

print(len(engine.trade_log), "trades executed")
print(len(engine.l1_snapshots), "L1 snapshots recorded")