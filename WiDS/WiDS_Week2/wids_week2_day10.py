# -*- coding: utf-8 -*-
"""WiDS_Week2_Day10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tHQ7IAyPl7eEPOS5XOvw5A1Q1lOzGPHN
"""

import heapq
from dataclasses import dataclass
from collections import deque
import time
import random
from abc import ABC, abstractmethod
import matplotlib.pyplot as plt
import numpy as np

@dataclass
class Order:
  order_id: int
  trader_id: int
  side: str
  type: str
  price: float | None
  qty: int
  timestamp: float
  status: str = "open"

@dataclass
class Trade:
  price: float
  qty: int
  buyer_id: int
  seller_id: int
  aggressor_side: str
  timestamp: float

class Agent(ABC):
  def __init__(self, agent_id, balance = 1_000_000, inventory = 0):
    self.id = agent_id
    self.balance = balance
    self.inventory = inventory

  @abstractmethod
  def get_action(self, market_snapshot):
    # returns dict describing an order intent
    pass

class OrderBook:
    def __init__(self):
        self.bids = {}
        self.asks = {}

        self.trade_log = []
        self.l1_snapshots = []

    def add_order(self, order: Order):
        if order.type == "limit":
            book = self.bids if order.side == "buy" else self.asks
            price = order.price

            if price not in book:
                book[price] = deque()

            book[price].append(order)

        self.match(order)
        self.record_l1(order.timestamp)

    def match(self, incoming: Order):
        while incoming.qty > 0:
            if incoming.side == "buy":
                if not self.asks:
                    break
                best_ask = min(self.asks)
                if incoming.type == "limit" and incoming.price < best_ask:
                    break
                resting = self.asks[best_ask][0]
                trade_price = best_ask
            else:
                if not self.bids:
                    break
                best_bid = max(self.bids)
                if incoming.type == "limit" and incoming.price > best_bid:
                    break
                resting = self.bids[best_bid][0]
                trade_price = best_bid

            trade_qty = min(incoming.qty, resting.qty)
            if trade_qty <= 0:
                break

            self.trade_log.append(
                Trade(
                    price=trade_price,
                    qty=trade_qty,
                    buyer_id=incoming.trader_id if incoming.side == "buy" else resting.trader_id,
                    seller_id=resting.trader_id if incoming.side == "buy" else incoming.trader_id,
                    aggressor_side=incoming.side,
                    timestamp=incoming.timestamp
                )
            )

            incoming.qty -= trade_qty
            resting.qty -= trade_qty

            if resting.qty == 0:
                if incoming.side == "buy":
                    self.asks[best_ask].popleft()
                    if not self.asks[best_ask]:
                        del self.asks[best_ask]
                else:
                    self.bids[best_bid].popleft()
                    if not self.bids[best_bid]:
                        del self.bids[best_bid]

    def record_l1(self, timestamp):
        if not self.bids or not self.asks:
            return

        best_bid = max(self.bids)
        best_ask = min(self.asks)

        if best_bid >= best_ask:
          return

        self.l1_snapshots.append({
            "timestamp": timestamp,
            "best_bid": best_bid,
            "best_ask": best_ask
        })

def seed_initial_liquidity(book: OrderBook, mid = 100.0, spread = 1.0):
  timestamp = 0.0

  bid_order = Order(
      order_id = 0,
      trader_id = -1,
      side = "buy",
      type = "limit",
      price = mid - spread/2,
      qty = 1_000,
      timestamp = timestamp
  )

  ask_order = Order(
      order_id = -1,
      trader_id = -2,
      side = "sell",
      type = "limit",
      price = mid + spread/2,
      qty = 1_000,
      timestamp = timestamp
  )

  book.add_order(bid_order)
  book.add_order(ask_order)

def intent_to_order(intent, agent_id, order_id, timestamp):
  return Order(
      order_id = order_id,
      trader_id = agent_id,
      side = intent["side"],
      type = intent["type"],
      price = intent["price"],
      qty = intent["qty"],
      timestamp = timestamp
  )

def get_l1_snapshot(order_book):
  best_bid = max(order_book.bids.keys()) if order_book.bids else None
  best_ask = min(order_book.asks.keys()) if order_book.asks else None

  return {
      "best_bid": best_bid,
      "best_ask": best_ask,
      "mid": (
          (best_bid + best_ask) / 2
          if best_bid is not None and best_ask is not None
          else None
      )
  }

def run_agent_simulation(agents, order_book, n_steps = 1_000):
  order_id = 1
  current_time = 0.0

  for _ in range(n_steps):
    current_time += random.expovariate(5)

    agent = random.choice(agents)
    snapshot = get_l1_snapshot(order_book)

    intents = agent.get_action(snapshot)
    if intents is None:
      continue

    if isinstance(intents, dict):
      intents = [intents]

    for intent in intents:
      order = intent_to_order(
        intent = intent,
        agent_id = agent.id,
        timestamp = current_time,
        order_id = order_id
      )
      order_book.add_order(order)
      order_id += 1

  return order_book

class MarketMakerAgent(Agent):
    def __init__(self, agent_id, spread=1.0, size=50):
        super().__init__(agent_id)
        self.spread = spread
        self.size = size

    def get_action(self, market_snapshot):
        best_bid = market_snapshot.get("best_bid")
        best_ask = market_snapshot.get("best_ask")

        if best_bid is None or best_ask is None:
            return None

        mid = (best_bid + best_ask) / 2

        return [
            {
                "side": "buy",
                "type": "limit",
                "price": round(mid - (self.spread / 2), 2),
                "qty": self.size
            },
            {
                "side": "sell",
                "type": "limit",
                "price": round(mid + (self.spread / 2), 2),
                "qty": self.size
            }
        ]

class MomentumAgent(Agent):
  def __init__(self, agent_id, window = 50):
    super().__init__(agent_id)
    self.window = window
    self.prices = deque(maxlen = window)

  def get_action(self, market_snapshot):
    mid = market_snapshot.get("mid")

    if mid is None:
      return None

    self.prices.append(mid)

    if len(self.prices) < self.window:
      return None

    sma = sum(self.prices) / len(self.prices)
    eps= random.uniform(-0.01, 0.01)

    if mid + eps > sma:
      return {
          "side": "buy",
          "type": "market",
          "price": None,
          "qty": 1
      }

    elif mid + eps < sma:
      return {
          "side": "sell",
          "type": "market",
          "price": None,
          "qty": 1
      }

    return None

class NoiseTrader(Agent):
  def get_action(self, snapshot):
    if snapshot["best_bid"] is None or snapshot["best_ask"] is None:
      return None

    side = random.choice(["buy", "sell"])
    qty = random.randint(1, 5)

    if random.random() < 0.3:
      price = snapshot["mid"] + random.uniform(-0.5, 0.5)
      return{
          "side": side,
          "type": "limit",
          "price": round(price, 2),
          "qty": qty
      }
    else:
      return{
          "side": side,
          "type": "market",
          "price": None,
          "qty": qty
      }

SCENARIOS = {
    "A": {"noise": 100, "mm": 0, "momentum": 0},
    "B": {"noise": 80, "mm": 20, "momentum": 0},
    "C": {"noise": 80, "mm": 0, "momentum": 20}
}

def build_agents(config):
  agents = []
  agent_id = 1

  for _ in range(config["noise"]):
    agents.append(NoiseTrader(agent_id))
    agent_id += 1

  for _ in range(config["mm"]):
    agents.append(MarketMakerAgent(agent_id))
    agent_id += 1

  for _ in range(config["momentum"]):
    agents.append(MomentumAgent(agent_id))
    agent_id += 1

  return agents

def run_scenario(name, config):
  random.seed(42)

  book = OrderBook()
  seed_initial_liquidity(book)

  agents = build_agents(config)

  engine = run_agent_simulation(
      agents = agents,
      order_book = book,
      n_steps = 30_000
  )

  return engine

results = {}

for name, config in SCENARIOS.items():
  print(f"Running scenario {name}")
  results[name] = run_scenario(name, config)

def extract_series(engine):
  times = []
  mids = []
  spreads = []

  for s in engine.l1_snapshots:
    mid = (s["best_bid"] + s["best_ask"]) / 2
    spread = s["best_ask"] - s["best_bid"]

    times.append(s["timestamp"])
    mids.append(mid)
    spreads.append(spread)

  return times, mids, spreads

def plot_scenario(name, times, mids, spreads):
  fig, axs = plt.subplots(2, 1, sharex = True, figsize = (10, 6))

  axs[0].plot(times, mids)
  axs[0].set_title(f"Scenario {name} - Mid Price")

  axs[1].plot(times, spreads)
  axs[1].set_title("Spread")

  plt.tight_layout()
  plt.savefig(f"scenario_{name}.png")
  plt.close()

def compute_metrics(mids, spreads):
  returns = np.diff(mids) / mids[:-1]

  return {
      "avg_spread": np.mean(spreads),
      "volatility": np.std(returns)
  }

"""PDF"""

from matplotlib.backends.backend_pdf import PdfPages
import pandas as pd

def plot_price_spread(times, mids, spreads, title):
  fig, axs = plt.subplots(2, 1, figsize = (10, 6), sharex = True)

  axs[0].plot(times, mids)
  axs[0].set_title(f"{title} - Mid Price")
  axs[0].set_ylabel("Price")

  axs[1].plot(times, spreads)
  axs[1].set_title("Spread")
  axs[1].set_ylabel("Spread")
  axs[1].set_xlabel("Time")

  plt.tight_layout()
  return fig

def plot_setup_page():
  fig, ax = plt.subplots(figsize=(10,6))
  ax.axis("off")

  text = (
      "Simulation Setup\n\n"
      "Total Agents: 100\n"
      "Simulation Length: 30,000 steps\n"
      "Snapshot Interval: event-driven\n"
      "Random Seed: 42\n\n"
      "Scenarios: \n"
      "A: 100 Noise\n"
      "B: 80 Noise + 20 Market Makers\n"
      "C: 80 Noise + 20 Momentum"
  )

  ax.text(0.05, 0.95, text, va = "top", fontsize = 12)
  return fig

def plot_comparison_table(metrics):
  fig, ax = plt.subplots(figsize = (8, 4))
  ax.axis("off")

  rows = ["Avg Spread", "Volatility"]
  cols = ["A", "B", "C"]

  table_data = [
      [metrics["A"]["avg_spread"], metrics["B"]["avg_spread"], metrics["C"]["avg_spread"]],
      [metrics["A"]["volatility"], metrics["B"]["volatility"], metrics["C"]["volatility"]]
  ]

  table = ax.table(
      cellText = np.round(table_data, 4),
      rowLabels = rows,
      colLabels = cols,
      loc = "center"
  )

  table.scale(1, 2)
  ax.set_title("Scenario Comparision", pad = 20)

  return fig

def plot_interpretation_page():
  fig, ax = plt.subplots(figsize = (10, 6))
  ax.axis("off")

  text = (
      "Interpretation\n\n"
      "Scenario A (Noise Only):\n"
      "Price nehaves like a random walk with wide spreads due to lack of liquidity provision.\n\n"
      "Scenario B (Noise + Market Makers):\n"
      "Market makers stabilize prices by continuously providing liquidity, leading to tighter spreads and lower volatility.\n\n"
      "Scenario C (Noise + Momentum):\n"
      "Momentum traders amplify price movements via positive feedback, increasing volatility "
      "and causing sudden crashes when trades reverse.\n\n"
      "Flash crashes emerge endogenously from liquidity withdraeal and aggressive order flow, without any explicit crash logic."
  )

  ax.text(0.05, 0.95, text, va = "top", fontsize = 11)
  return fig

def rolling_volatility(mids, window = 50):
  mids = np.array(mids)
  returns = np.diff(mids) / mids[:-1]
  vol = np.full(len(mids), np.nan)

  for i in range(window, len(returns)):
    vol[i] = np.std(returns[i - window:i])

  return vol

def plot_rolling_volatility(times, mids, window = 50, title = "Rolling Volatility"):
  vol = rolling_volatility(mids, window)

  fig, ax = plt.subplots(figsize = (10, 4))
  ax.axis("off")
  ax.plot(times, vol)
  ax.set_title(f"{title} (window = {window})")
  ax.set_ylabel("Volatility")
  ax.set_xlabel("Time")

  plt.tight_layout()
  return fig

def trades_to_ohlc(trade_log):
  df = pd.DataFrame(
      [(t.timestamp, t.price) for t in trade_log],
      columns = ["timestamp", "price"]
  )

  df["timestamp"] = pd.to_datetime(df["timestamp"], unit = "s")
  df.set_index("timestamp", inplace = True)

  ohlc = df["price"].resample("1min").ohlc()
  ohlc.dropna(inplace = True)

  assert(ohlc["low"] <= ohlc["high"]).all()

  return ohlc

def plot_candlestick(ohlc, title = "1-Minute Candlestick"):
  fig, ax = plt.subplots(figsize = (10, 4))

  for idx, row in ohlc.iterrows():
    color = "green" if row["close"] >= row["open"] else "red"

    ax.plot([idx, idx], [row["low"], row["high"]], color = "black")
    ax.plot(
        [idx, idx],
        [row["open"], row["close"]],
        color = color,
        linewidth = 6
    )

  ax.set_title(title)
  ax.set_ylabel("Price")
  ax.set_xlabel("Time")

  plt.tight_layout()
  return fig

def generate_pdf(results, metrics, filename="simulation_report.pdf"):
    from matplotlib.backends.backend_pdf import PdfPages

    with PdfPages(filename) as pdf:

        fig = plot_setup_page()
        pdf.savefig(fig)
        plt.close(fig)

        for name in ["A", "B", "C"]:
            engine = results[name]
            times, mids, spreads = extract_series(engine)

            fig = plot_price_spread(times, mids, spreads, f"Scenario {name}")
            pdf.savefig(fig)
            plt.close(fig)

            fig = plot_rolling_volatility(
                times, mids, title=f"Scenario {name} Volatility"
            )
            pdf.savefig(fig)
            plt.close(fig)

            ohlc = trades_to_ohlc(engine.trade_log)
            fig = plot_candlestick(ohlc, title=f"Scenario {name} Candlestick")
            pdf.savefig(fig)
            plt.close(fig)

        fig = plot_comparison_table(metrics)
        pdf.savefig(fig)
        plt.close(fig)

        fig = plot_interpretation_page()
        pdf.savefig(fig)
        plt.close(fig)

    print(f"Saved {filename}")

metrics = {}

for name, engine, in results.items():
  times, mids, spreads = extract_series(engine)
  metrics[name] = compute_metrics(mids, spreads)

generate_pdf(results, metrics)