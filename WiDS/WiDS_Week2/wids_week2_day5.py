# -*- coding: utf-8 -*-
"""WiDS_Week2_Day5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1la2zOLBygajretvUFVRu8febcc_CM4Dl
"""

import heapq
from collections import deque
from dataclasses import dataclass
import time
import random

@dataclass
class Order:
  order_id: int
  trader_id: int
  side: str
  type: str
  price: float | None
  qty: int
  timestamp: float
  status: str = "open"

@dataclass
class Trade:
  price: float
  qty: int
  buyer_id: int
  seller_id: int
  aggressor_side: str
  timestamp: float

class OrderBook:
    def __init__(self):
        self.bids = {}
        self.asks = {}
        self.bid_heap = []
        self.ask_heap = []

        self.trade_log = []
        self.l1_snapshots = []

    def add_order(self, order: Order):
        if order.type == "limit":
            book = self.bids if order.side == "buy" else self.asks
            heap = self.bid_heap if order.side == "buy" else self.ask_heap
            price = order.price

            if price not in book:
                book[price] = deque()
                heapq.heappush(heap, -price if order.side == "buy" else price)

            book[price].append(order)

        self.match(order)
        self.record_l1(order.timestamp)

    def match(self, incoming: Order):
        while incoming.qty > 0:
            if incoming.side == "buy":
                if not self.ask_heap:
                    break
                best_ask = self.ask_heap[0]
                if incoming.type == "limit" and incoming.price < best_ask:
                    break
                resting = self.asks[best_ask][0]
                trade_price = best_ask
            else:
                if not self.bid_heap:
                    break
                best_bid = -self.bid_heap[0]
                if incoming.type == "limit" and incoming.price > best_bid:
                    break
                resting = self.bids[best_bid][0]
                trade_price = best_bid

            trade_qty = min(incoming.qty, resting.qty)
            if trade_qty <= 0:
                break

            self.trade_log.append(
                Trade(
                    price=trade_price,
                    qty=trade_qty,
                    buyer_id=incoming.trader_id if incoming.side == "buy" else resting.trader_id,
                    seller_id=resting.trader_id if incoming.side == "buy" else incoming.trader_id,
                    aggressor_side=incoming.side,
                    timestamp=incoming.timestamp
                )
            )

            incoming.qty -= trade_qty
            resting.qty -= trade_qty

            if resting.qty == 0:
                if incoming.side == "buy":
                    self.asks[best_ask].popleft()
                    if not self.asks[best_ask]:
                        del self.asks[best_ask]
                        heapq.heappop(self.ask_heap)
                else:
                    self.bids[best_bid].popleft()
                    if not self.bids[best_bid]:
                        del self.bids[best_bid]
                        heapq.heappop(self.bid_heap)

    def record_l1(self, timestamp):
        if not self.bids or not self.asks:
            return

        best_bid = max(self.bids)
        best_ask = min(self.asks)

        if best_bid >= best_ask:
          return

        self.l1_snapshots.append({
            "timestamp": timestamp,
            "best_bid": best_bid,
            "best_ask": best_ask
        })

def generate_random_order(order_id, current_time, mid_price=100.0):
    side = random.choice(["buy", "sell"])

    order_type = random.choices(
        ["limit", "market"],
        weights=[0.8, 0.2]
    )[0]

    qty = random.randint(1, 20)

    if order_type == "market":
        price = None
    else:
        if side == "buy":
            price = round(mid_price - random.uniform(0.01, 2.0), 2)
        else:
            price = round(mid_price + random.uniform(0.01, 2.0), 2)

    return Order(
        order_id=order_id,
        trader_id=random.randint(1, 50),
        side=side,
        type=order_type,
        price=price,
        qty=qty,
        timestamp=current_time
    )

def run_simulation(n=1000000, seed=42):
    random.seed(seed)
    book = OrderBook()
    t = 0.0

    for i in range(n):
        t += random.expovariate(5)
        book.add_order(generate_random_order(i, t))

    return book

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages

SEED = 42
random.seed(SEED)
np.random.seed(SEED)

engine = run_simulation()

tape_df = pd.DataFrame(engine.trade_log)
tape_df = pd.DataFrame([t.__dict__ for t in engine.trade_log])

assert {'timestamp', 'price', 'qty'}.issubset(tape_df.columns)

tape_df['timestamp'] = pd.to_datetime(tape_df['timestamp'], unit = 's')
tape_df.set_index('timestamp', inplace = True)

l1_df = pd.DataFrame(engine.l1_snapshots, columns = ['timestamp', 'best_bid', 'best_ask'])

l1_df['timestamp'] = pd.to_datetime(l1_df['timestamp'], unit='s')
l1_df.set_index('timestamp', inplace=True)

l1_df['spread'] = l1_df['best_ask'] - l1_df['best_bid']
l1_df['mid_price'] = (l1_df['best_bid'] + l1_df['best_ask']) / 2

assert (tape_df['price'] >= 0).all()
assert (tape_df['qty'] > 0).all()

assert (l1_df['best_bid'] >= 0).all()
assert (l1_df['best_ask'] >= 0).all()

assert (l1_df["spread"] >= 0).all()

ohlc = tape_df['price'].resample('1min').ohlc()
volume = tape_df['qty'].resample('1min').sum()

assert (ohlc['high'] >= ohlc['low']).all()
assert (ohlc['high'] >= ohlc['open']).all()
assert (ohlc['high'] >= ohlc['close']).all()

mid = l1_df["mid_price"].dropna()
mid_vol = np.log(mid).diff().rolling(50).std().dropna()

trade_ret = np.log(tape_df["price"]).diff().dropna()

print("Mid-vol:", mid_vol.mean())
print("Trade-vol:", trade_ret.std())

assert mid_vol.mean() < trade_ret.std()

fig_diag, axes = plt.subplots(4, 1, figsize = (10, 12), sharex = True)

axes[0].plot(ohlc.index, ohlc['close'])
axes[0].set_title("Price (Close)")

axes[1].bar(volume.index, volume)
axes[1].set_title("Volume")

axes[2].plot(l1_df.index, l1_df['spread'])
axes[2].set_title("Spread")

axes[3].plot(mid_vol.index, mid_vol)
axes[3].set_title("Mid-Price Volatility (Rolling)")

!pip install mplfinance

ohlc_mpf = ohlc.copy()
ohlc_mpf.columns = ['Open', 'High', 'Low', 'Close']

ohlc_mpf['Volume'] = volume

import mplfinance as mpf

mpf.plot(
    ohlc_mpf,
    type='candle',
    volume=True,
    style='classic',
    title='Candlestick Chart (from Trade Tape)',
    ylabel='Price',
    ylabel_lower='Volume'
)

ohlc_mpf = ohlc.copy()
ohlc_mpf.columns = ['Open', 'High', 'Low', 'Close']

ohlc_mpf['Volume'] = volume

fig_candle, _ = mpf.plot(
    ohlc_mpf,
    type='candle',
    volume=True,
    style='classic',
    title='Candlestick Chart (from Trade Tape)',
    returnfig=True
)

with PdfPages('simulation_report.pdf') as pdf:
    pdf.savefig(fig_diag)
    pdf.savefig(fig_candle)

plt.close(fig_diag)
plt.close(fig_candle)