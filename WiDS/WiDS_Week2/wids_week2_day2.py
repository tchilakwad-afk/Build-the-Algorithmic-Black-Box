# -*- coding: utf-8 -*-
"""WiDS_Week2_Day2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ni3ukZ6QyWg6nkGxdocvnTzEqAyXq96B
"""

import heapq
from collections import deque
from dataclasses import dataclass
import time

@dataclass
class Order:
  order_id: int
  trader_id: int
  side: str
  type: str
  price: float | None
  qty: int
  timestamp: float
  status: str = "open"

@dataclass
class Trade:
  price: float
  qty: int
  buyer_id: int
  seller_id: int
  timestamp: float

class OrderBook:
  def __init__(self):
    self.bids = {}
    self.asks = {}

    self.bid_heap = []
    self.ask_heap = []

    self.trades = []

  def add_order(self, order: Order):
    if order.type == "market":
      self.match(order)
      return

    if order.side == "buy":
      if order.price not in self.bids:
        self.bids[order.price] = deque()
        heapq.heappush(self.bid_heap, -order.price)
      self.bids[order.price].append(order)

    else:
      if order.price not in self.asks:
        self.asks[order.price] = deque()
        heapq.heappush(self.ask_heap, order.price)
      self.asks[order.price].append(order)

    self.match(order)

  def match(self, incoming: Order):
    while incoming.qty > 0:
      if incoming.side == "buy":
        if not self.ask_heap:
          break

        best_ask = self.ask_heap[0]

        if incoming.type == "limit" and incoming.price < best_ask:
          break

        resting = self.asks[best_ask][0]

      else:
        if not self.bid_heap:
          break

        best_bid = -self.bid_heap[0]

        if incoming.type == "limit" and incoming.price > best_bid:
          break

        resting = self.bids[best_bid][0]

      trade_qty = min(incoming.qty, resting.qty)

      trade = Trade(
          price = best_ask if incoming.side == "buy" else best_bid,
          qty = trade_qty,
          buyer_id = incoming.trader_id if incoming.side == "buy" else resting.trader_id,
          seller_id = resting.trader_id if incoming.side == "buy" else incoming.trader_id,
          timestamp = time.time()
      )

      self.trades.append(trade)

      incoming.qty -= trade_qty
      resting.qty -= trade_qty

      if resting.qty == 0:
        resting.status = "filled"

        if incoming.side == "buy":
          self.asks[best_ask].popleft()
          if not self.asks[best_ask]:
            del self.asks[best_ask]
            heapq.heappop(self.ask_heap)

        else:
          self.bids[best_bid].popleft()
          if not self.bids[best_bid]:
            del self.bids[best_bid]
            heapq.heappop(self.bid_heap)

    incoming.status = "filled" if incoming.qty == 0 else "partial"

book = OrderBook()

asks = [(101, 10), (102, 20), (103, 30)]
oid = 1

for price, qty in asks:
  book.add_order(
      Order(
          order_id = oid,
          trader_id = oid,
          side = "sell",
          type = "limit",
          price = price,
          qty = qty,
          timestamp = time.time()
      )
  )
  oid += 1

market_buy = Order(
    order_id = 999,
    trader_id = 999,
    side = "buy",
    type = "market",
    price = None,
    qty = 60,
    timestamp = time.time()
)

book.add_order(market_buy)

for t in book.trades:
  print(t)